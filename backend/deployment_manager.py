# deployment_manager.py
import os
import sys
import json
import subprocess
import shutil
from pathlib import Path
import asyncio
import aiohttp
from typing import Dict, List, Any
import logging

logger = logging.getLogger(__name__)

class DeploymentManager:
    """Manages agent deployments for both single and multi-agent architectures"""
    
    def __init__(self, base_path: str = "./deployments"):
        self.base_path = Path(base_path)
        self.base_path.mkdir(exist_ok=True)
        
    def generate_single_agent_adk(self, agent: Dict[str, Any], deployment_id: str) -> str:
        """Generate single agent using Google ADK"""
        
        agent_script = f'''#!/usr/bin/env python3
"""
Agent: {agent['name']}
Type: Single Agent (Google ADK)
Model: {agent['model_name']}
Generated by Agent Authoring Platform
"""

import os
import sys
import json
import asyncio
from typing import Dict, List, Any
from flask import Flask, request, jsonify, render_template_string
from flask_cors import CORS

# Google ADK imports (placeholder - replace with actual ADK imports)
# from google.genai import Client, Model
# from google.genai.tools import Tool

# Set static environment variables
os.environ["BASE_URL"] = "https://api.example.com"
os.environ["CERTS_PATH"] = "/path/to/certs"
os.environ["APIGEE_URL"] = "https://apigee.example.com"
os.environ["USE_API_GATEWAY"] = "true"

# Set agent-specific environment variables
os.environ["USECASE_ID"] = "{agent.get('usecase_id', '')}"
os.environ["API_KEY"] = "{agent.get('api_key', '')}"
os.environ["CONSUMER_KEY"] = "{agent.get('consumer_key', '')}"
os.environ["CONSUMER_SECRET"] = "{agent.get('consumer_secret', '')}"

# Initialize Flask app for Chat UI
app = Flask(__name__)
CORS(app)

# MCP Tool configurations
MCP_TOOLS = {json.dumps(self._get_mcp_configs(agent), indent=2)}

class Agent:
    def __init__(self):
        self.name = "{agent['name']}"
        self.model = "{agent['model_name']}"
        self.system_instruction = """{agent['instruction']}"""
        self.tools = []
        self._initialize_tools()
        
    def _initialize_tools(self):
        """Initialize MCP tools for the agent"""
        for tool_config in MCP_TOOLS:
            # Set tool-specific environment variables
            for env_name, env_value in tool_config['env_values'].items():
                os.environ[env_name] = env_value
            
            # Import and initialize the MCP tool
            try:
                # Dynamic import of MCP package
                module_name = tool_config['package_name']
                # tool_module = __import__(module_name, fromlist=['Tool'])
                # tool_instance = tool_module.Tool()
                # self.tools.append(tool_instance)
                print(f"Initialized MCP tool: {{tool_config['name']}}")
            except Exception as e:
                print(f"Failed to initialize {{tool_config['name']}}: {{str(e)}}")
    
    async def process_message(self, message: str) -> str:
        """Process incoming message and return response"""
        # TODO: Implement actual ADK agent processing
        # This is a placeholder implementation
        
        # For now, return a mock response
        return f"Agent {{self.name}} received: {{message}}"

# Initialize agent
agent = Agent()

# Chat UI HTML template
CHAT_UI_TEMPLATE = """
<!DOCTYPE html>
<html>
<head>
    <title>{{ agent_name }} - Chat Interface</title>
    <style>
        body {{
            font-family: Arial, sans-serif;
            margin: 0;
            padding: 0;
            background-color: #f0f2f5;
        }}
        .container {{
            max-width: 800px;
            margin: 0 auto;
            height: 100vh;
            display: flex;
            flex-direction: column;
        }}
        .header {{
            background-color: #075e54;
            color: white;
            padding: 20px;
            text-align: center;
        }}
        .chat-container {{
            flex: 1;
            overflow-y: auto;
            padding: 20px;
            background-color: white;
        }}
        .message {{
            margin: 10px 0;
            padding: 10px;
            border-radius: 8px;
            max-width: 70%;
        }}
        .user-message {{
            background-color: #dcf8c6;
            margin-left: auto;
            text-align: right;
        }}
        .agent-message {{
            background-color: #e8e8e8;
        }}
        .input-container {{
            padding: 20px;
            background-color: #f0f2f5;
            display: flex;
            gap: 10px;
        }}
        #message-input {{
            flex: 1;
            padding: 10px;
            border: 1px solid #ddd;
            border-radius: 20px;
            outline: none;
        }}
        #send-button {{
            padding: 10px 20px;
            background-color: #075e54;
            color: white;
            border: none;
            border-radius: 20px;
            cursor: pointer;
        }}
        #send-button:hover {{
            background-color: #064e46;
        }}
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>{{ agent_name }}</h1>
            <p>{{ agent_description }}</p>
        </div>
        <div class="chat-container" id="chat-container"></div>
        <div class="input-container">
            <input type="text" id="message-input" placeholder="Type your message..." onkeypress="handleKeyPress(event)">
            <button id="send-button" onclick="sendMessage()">Send</button>
        </div>
    </div>
    
    <script>
        async function sendMessage() {{
            const input = document.getElementById('message-input');
            const message = input.value.trim();
            
            if (!message) return;
            
            // Add user message to chat
            addMessage(message, 'user');
            input.value = '';
            
            try {{
                const response = await fetch('/chat', {{
                    method: 'POST',
                    headers: {{ 'Content-Type': 'application/json' }},
                    body: JSON.stringify({{ message: message }})
                }});
                
                const data = await response.json();
                addMessage(data.response, 'agent');
            }} catch (error) {{
                addMessage('Error: Failed to get response', 'agent');
            }}
        }}
        
        function addMessage(message, sender) {{
            const chatContainer = document.getElementById('chat-container');
            const messageDiv = document.createElement('div');
            messageDiv.className = `message ${{sender}}-message`;
            messageDiv.textContent = message;
            chatContainer.appendChild(messageDiv);
            chatContainer.scrollTop = chatContainer.scrollHeight;
        }}
        
        function handleKeyPress(event) {{
            if (event.key === 'Enter') {{
                sendMessage();
            }}
        }}
    </script>
</body>
</html>
"""

@app.route('/')
def index():
    return render_template_string(
        CHAT_UI_TEMPLATE,
        agent_name=agent.name,
        agent_description=f"Model: {{agent.model}} | Tools: {{len(agent.tools)}}"
    )

@app.route('/chat', methods=['POST'])
async def chat():
    data = request.json
    message = data.get('message', '')
    
    response = await agent.process_message(message)
    
    return jsonify({{'response': response}})

@app.route('/health')
def health():
    return jsonify({{
        'status': 'healthy',
        'agent': agent.name,
        'tools': len(agent.tools)
    }})

if __name__ == '__main__':
    print(f"Starting agent '{{agent.name}}' on port 8100...")
    print(f"Chat UI available at: http://localhost:8100")
    app.run(host='0.0.0.0', port=8100, debug=False)
'''
        
        return agent_script
    
    def generate_multi_agent_a2a(self, agents: List[Dict[str, Any]], deployment_id: str) -> Dict[str, str]:
        """Generate multi-agent architecture using A2A protocol"""
        
        scripts = {}
        
        # Generate orchestrator agent
        orchestrator = next((a for a in agents if a['agent_type'] == 'orchestrator'), None)
        if orchestrator:
            scripts['orchestrator.py'] = self._generate_orchestrator_script(orchestrator, agents)
        
        # Generate worker agents
        for agent in agents:
            if agent['agent_type'] == 'worker':
                scripts[f"worker_{agent['agent_id']}.py"] = self._generate_worker_script(agent)
        
        # Generate A2A coordinator
        scripts['a2a_coordinator.py'] = self._generate_a2a_coordinator_script(agents)
        
        return scripts
    
    def _generate_orchestrator_script(self, orchestrator: Dict[str, Any], all_agents: List[Dict[str, Any]]) -> str:
        """Generate orchestrator agent script"""
        
        worker_agents = [a for a in all_agents if a['agent_type'] == 'worker']
        
        return f'''#!/usr/bin/env python3
"""
Orchestrator Agent: {orchestrator['name']}
Type: Multi-Agent Orchestrator (A2A Protocol)
Model: {orchestrator['model_name']}
"""

import asyncio
import aiohttp
import json
from typing import Dict, List, Any
from dataclasses import dataclass

@dataclass
class WorkerAgent:
    agent_id: str
    name: str
    endpoint: str
    capabilities: List[str]

class OrchestratorAgent:
    def __init__(self):
        self.name = "{orchestrator['name']}"
        self.model = "{orchestrator['model_name']}"
        self.system_instruction = """{orchestrator['instruction']}"""
        self.workers = self._initialize_workers()
        
    def _initialize_workers(self) -> List[WorkerAgent]:
        """Initialize worker agent connections"""
        workers = []
        {self._generate_worker_init_code(worker_agents)}
        return workers
    
    async def process_request(self, request: Dict[str, Any]) -> Dict[str, Any]:
        """Process incoming request and coordinate with worker agents"""
        
        # Analyze request to determine which workers to engage
        task_type = request.get('task_type', 'general')
        message = request.get('message', '')
        
        # Simple routing logic (to be enhanced with actual AI model)
        responses = {{}}
        
        # Send tasks to relevant workers
        async with aiohttp.ClientSession() as session:
            tasks = []
            for worker in self.workers:
                # Determine if this worker should handle the task
                if self._should_engage_worker(worker, task_type, message):
                    task = self._send_to_worker(session, worker, request)
                    tasks.append(task)
            
            # Collect responses
            worker_responses = await asyncio.gather(*tasks, return_exceptions=True)
            
            for i, response in enumerate(worker_responses):
                if not isinstance(response, Exception):
                    responses[self.workers[i].name] = response
        
        # Aggregate and synthesize responses
        final_response = self._synthesize_responses(responses, request)
        
        return {{
            'orchestrator': self.name,
            'final_response': final_response,
            'worker_responses': responses
        }}
    
    def _should_engage_worker(self, worker: WorkerAgent, task_type: str, message: str) -> bool:
        """Determine if a worker should handle the task"""
        # TODO: Implement intelligent routing based on worker capabilities
        return True
    
    async def _send_to_worker(self, session: aiohttp.ClientSession, 
                            worker: WorkerAgent, request: Dict[str, Any]) -> Dict[str, Any]:
        """Send request to worker agent"""
        try:
            async with session.post(
                f"{{worker.endpoint}}/process",
                json=request,
                timeout=aiohttp.ClientTimeout(total=30)
            ) as response:
                return await response.json()
        except Exception as e:
            return {{'error': str(e), 'worker': worker.name}}
    
    def _synthesize_responses(self, responses: Dict[str, Any], 
                            original_request: Dict[str, Any]) -> str:
        """Synthesize multiple worker responses into final response"""
        # TODO: Implement intelligent response synthesis using AI model
        
        if not responses:
            return "No workers responded to the request."
        
        # Simple aggregation for now
        synthesis = f"Based on analysis from {{len(responses)}} agents:\\n\\n"
        for worker, response in responses.items():
            if 'error' not in response:
                synthesis += f"**{{worker}}**: {{response.get('response', 'No response')}}\\n\\n"
        
        return synthesis

# Initialize orchestrator
orchestrator = OrchestratorAgent()

# REST API for orchestrator
from flask import Flask, request, jsonify
app = Flask(__name__)

@app.route('/orchestrate', methods=['POST'])
async def orchestrate():
    data = request.json
    response = await orchestrator.process_request(data)
    return jsonify(response)

@app.route('/health')
def health():
    return jsonify({{
        'status': 'healthy',
        'orchestrator': orchestrator.name,
        'workers': len(orchestrator.workers)
    }})

if __name__ == '__main__':
    print(f"Starting Orchestrator '{{orchestrator.name}}'...")
    app.run(host='0.0.0.0', port=8200, debug=False)
'''
    
    def _generate_worker_script(self, agent: Dict[str, Any]) -> str:
        """Generate worker agent script"""
        
        return f'''#!/usr/bin/env python3
"""
Worker Agent: {agent['name']}
Type: Multi-Agent Worker (A2A Protocol)
Model: {agent['model_name']}
"""

import os
import asyncio
from flask import Flask, request, jsonify

# Set environment variables
os.environ["USECASE_ID"] = "{agent.get('usecase_id', '')}"
os.environ["API_KEY"] = "{agent.get('api_key', '')}"
os.environ["CONSUMER_KEY"] = "{agent.get('consumer_key', '')}"
os.environ["CONSUMER_SECRET"] = "{agent.get('consumer_secret', '')}"

# MCP Tool configurations
MCP_TOOLS = {json.dumps(self._get_mcp_configs(agent), indent=2)}

class WorkerAgent:
    def __init__(self):
        self.agent_id = "{agent['agent_id']}"
        self.name = "{agent['name']}"
        self.model = "{agent['model_name']}"
        self.system_instruction = """{agent['instruction']}"""
        self.tools = []
        self._initialize_tools()
    
    def _initialize_tools(self):
        """Initialize MCP tools for the worker"""
        for tool_config in MCP_TOOLS:
            # Set tool-specific environment variables
            for env_name, env_value in tool_config['env_values'].items():
                os.environ[env_name] = env_value
            
            try:
                # Import MCP tool
                print(f"Initialized MCP tool: {{tool_config['name']}}")
            except Exception as e:
                print(f"Failed to initialize {{tool_config['name']}}: {{str(e)}}")
    
    async def process(self, request: dict) -> dict:
        """Process request from orchestrator"""
        message = request.get('message', '')
        
        # TODO: Implement actual processing with AI model and tools
        # This is a placeholder
        
        response = {{
            'agent_id': self.agent_id,
            'agent_name': self.name,
            'response': f"Worker {{self.name}} processed: {{message}}",
            'tools_used': [tool['name'] for tool in MCP_TOOLS]
        }}
        
        return response

# Initialize worker
worker = WorkerAgent()

# REST API
app = Flask(__name__)

@app.route('/process', methods=['POST'])
async def process():
    data = request.json
    response = await worker.process(data)
    return jsonify(response)

@app.route('/health')
def health():
    return jsonify({{
        'status': 'healthy',
        'agent': worker.name,
        'agent_id': worker.agent_id,
        'tools': len(worker.tools)
    }})

if __name__ == '__main__':
    port = {8300 + hash(agent['agent_id']) % 100}  # Dynamic port based on agent ID
    print(f"Starting Worker '{{worker.name}}' on port {{port}}...")
    app.run(host='0.0.0.0', port=port, debug=False)
'''
    
    def _generate_a2a_coordinator_script(self, agents: List[Dict[str, Any]]) -> str:
        """Generate A2A protocol coordinator script"""
        
        return f'''#!/usr/bin/env python3
"""
A2A Protocol Coordinator
Manages communication between agents in multi-agent architecture
"""

import asyncio
import aiohttp
from typing import Dict, List, Any
import json
import logging

logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)

class A2ACoordinator:
    def __init__(self):
        self.agents = {json.dumps(self._format_agents_for_coordinator(agents), indent=2)}
        self.health_check_interval = 30  # seconds
        
    async def start(self):
        """Start the A2A coordinator"""
        logger.info("Starting A2A Coordinator...")
        
        # Start health monitoring
        asyncio.create_task(self._monitor_agents_health())
        
        # Start message routing service
        await self._start_routing_service()
    
    async def _monitor_agents_health(self):
        """Monitor health of all agents"""
        while True:
            for agent in self.agents:
                try:
                    async with aiohttp.ClientSession() as session:
                        async with session.get(
                            f"{{agent['endpoint']}}/health",
                            timeout=aiohttp.ClientTimeout(total=5)
                        ) as response:
                            if response.status == 200:
                                agent['status'] = 'healthy'
                            else:
                                agent['status'] = 'unhealthy'
                except Exception as e:
                    agent['status'] = 'offline'
                    logger.error(f"Agent {{agent['name']}} health check failed: {{e}}")
            
            await asyncio.sleep(self.health_check_interval)
    
    async def _start_routing_service(self):
        """Start the message routing service"""
        from aiohttp import web
        
        async def route_message(request):
            """Route messages between agents"""
            data = await request.json()
            
            # Implement A2A protocol routing logic
            source_agent = data.get('source')
            target_agent = data.get('target')
            message = data.get('message')
            
            # Find target agent
            target = next((a for a in self.agents if a['id'] == target_agent), None)
            if not target:
                return web.json_response({{'error': 'Target agent not found'}}, status=404)
            
            # Forward message
            async with aiohttp.ClientSession() as session:
                try:
                    async with session.post(
                        f"{{target['endpoint']}}/receive",
                        json={{
                            'source': source_agent,
                            'message': message
                        }}
                    ) as response:
                        result = await response.json()
                        return web.json_response(result)
                except Exception as e:
                    return web.json_response({{'error': str(e)}}, status=500)
        
        app = web.Application()
        app.router.add_post('/route', route_message)
        
        runner = web.AppRunner(app)
        await runner.setup()
        site = web.TCPSite(runner, '0.0.0.0', 8400)
        await site.start()
        
        logger.info("A2A Routing service started on port 8400")
        
        # Keep the service running
        await asyncio.Event().wait()

async def main():
    coordinator = A2ACoordinator()
    await coordinator.start()

if __name__ == '__main__':
    asyncio.run(main())
'''
    
    def _get_mcp_configs(self, agent: Dict[str, Any]) -> List[Dict[str, Any]]:
        """Extract MCP configurations for an agent"""
        mcp_configs = []
        for mcp in agent.get('mcp_tools', []):
            config = {
                'name': mcp['mcp_tool']['name'],
                'package_name': mcp['mcp_tool']['package_name'],
                'env_values': mcp['env_values']
            }
            mcp_configs.append(config)
        return mcp_configs
    
    def _generate_worker_init_code(self, workers: List[Dict[str, Any]]) -> str:
        """Generate worker initialization code for orchestrator"""
        code = ""
        for worker in workers:
            port = 8300 + hash(worker['agent_id']) % 100
            code += f'''
        workers.append(WorkerAgent(
            agent_id="{worker['agent_id']}",
            name="{worker['name']}",
            endpoint="http://localhost:{port}",
            capabilities=[]  # TODO: Define capabilities
        ))'''
        return code
    
    def _format_agents_for_coordinator(self, agents: List[Dict[str, Any]]) -> List[Dict[str, Any]]:
        """Format agent information for A2A coordinator"""
        formatted = []
        for agent in agents:
            if agent['agent_type'] == 'orchestrator':
                port = 8200
            else:
                port = 8300 + hash(agent['agent_id']) % 100
            
            formatted.append({
                'id': agent['agent_id'],
                'name': agent['name'],
                'type': agent['agent_type'],
                'endpoint': f"http://localhost:{port}",
                'status': 'unknown'
            })
        return formatted
    
    async def deploy_single_agent(self, agent: Dict[str, Any], deployment_id: str) -> Dict[str, Any]:
        """Deploy a single agent"""
        deployment_path = self.base_path / deployment_id
        deployment_path.mkdir(exist_ok=True)
        
        # Generate agent script
        agent_script = self.generate_single_agent_adk(agent, deployment_id)
        
        # Write script
        script_path = deployment_path / "agent.py"
        with open(script_path, 'w') as f:
            f.write(agent_script)
        
        # Create virtual environment
        venv_path = deployment_path / "venv"
        subprocess.run([sys.executable, "-m", "venv", str(venv_path)], check=True)
        
        # Install requirements
        pip_path = venv_path / ("Scripts" if sys.platform == "win32" else "bin") / "pip"
        requirements = [
            "flask",
            "flask-cors",
            "aiohttp",
            # Add Google ADK package when available
            # "google-genai-sdk",
        ]
        
        # Add MCP packages
        for mcp in agent.get('mcp_tools', []):
            requirements.append(mcp['mcp_tool']['package_name'])
        
        subprocess.run([str(pip_path), "install"] + requirements, check=True)
        
        # Create start script
        start_script = deployment_path / "start.sh"
        python_path = venv_path / ("Scripts" if sys.platform == "win32" else "bin") / "python"
        
        with open(start_script, 'w') as f:
            f.write(f'''#!/bin/bash
cd {deployment_path}
{python_path} agent.py
''')
        
        os.chmod(start_script, 0o755)
        
        return {
            'deployment_id': deployment_id,
            'deployment_path': str(deployment_path),
            'start_script': str(start_script),
            'status': 'ready'
        }

# Usage example
if __name__ == "__main__":
    manager = DeploymentManager()
    
    # Example single agent
    single_agent = {
        'agent_id': 'agent-123',
        'name': 'Customer Support Agent',
        'instruction': 'You are a helpful customer support agent.',
        'model_name': 'gpt-4',
        'agent_type': 'single',
        'mcp_tools': [
            {
                'mcp_tool': {
                    'name': 'Email Tool',
                    'package_name': 'mcp-email-tool'
                },
                'env_values': {
                    'SMTP_SERVER': 'smtp.gmail.com',
                    'SMTP_PORT': '587'
                }
            }
        ]
    }
    
    # Deploy single agent
    result = asyncio.run(manager.deploy_single_agent(single_agent, 'deployment-001'))
    print(f"Deployment result: {result}")
